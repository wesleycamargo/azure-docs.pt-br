---
title: "Lista de verificação de escalabilidade | Microsoft Docs"
description: "Diretrizes de lista de verificação de escalabilidade para questões de design de dimensionamento automático do Azure."
services: 
documentationcenter: na
author: dragon119
manager: christb
editor: 
tags: 
ms.assetid: e505c665-a095-4013-a4b6-ccd79bcb2e1e
ms.service: best-practice
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/13/2016
ms.author: masashin
translationtype: Human Translation
ms.sourcegitcommit: 219dcbfdca145bedb570eb9ef747ee00cc0342eb
ms.openlocfilehash: eeb06f2d0f20b043728fe6daacbfbaa9165cb01d


---
# <a name="scalability-checklist"></a>Lista de verificação de escalabilidade
[!INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Design de serviço
* **Particione a carga de trabalho**. Crie partes do processo para serem decompostas e distintas. Minimize o tamanho de cada parte seguindo as regras comuns para a separação de preocupações e o princípio da responsabilidade exclusiva. Isso permite que os componentes sejam distribuídos de maneira a maximizar o uso de cada unidade de computação (como um servidor de banco de dados ou uma função). Isso também facilita o dimensionamento do aplicativo ao adicionar instâncias de recursos específicos. Para saber mais, consulte [Diretrizes de particionamento de computação](https://msdn.microsoft.com/library/dn589773.aspx).
* **Projete o dimensionamento**. O dimensionamento permite que os aplicativos reajam a uma carga variável, aumentando e diminuindo o número de instâncias de funções, de filas e de outros serviços usados. No entanto, o aplicativo deve ser projetado com isso em mente. Por exemplo, o aplicativo e os serviços usados não devem possuir um estado para permitir que as solicitações sejam roteadas para qualquer instância. Isso também impede que a adição ou a remoção de instâncias específicas afetem negativamente os usuários atuais. Você também deve implementar a configuração ou a detecção automática de instâncias à medida que elas forem adicionadas e removidas de forma que o código no aplicativo possa executar o roteamento necessário. Por exemplo, um aplicativo Web pode usar um conjunto de filas em uma abordagem de round-robin para rotear solicitações para serviços em segundo plano em execução nas funções de trabalho. O aplicativo Web deve ser capaz de detectar alterações no número de filas para rotear solicitações e balancear a carga no aplicativo com êxito.
* **Dimensione como uma unidade**. Planeje os recursos adicionais para acomodar o crescimento. Para cada recurso, saiba quais são os limites de dimensionamento superiores e use a fragmentação ou a decomposição para ir além desses limites. Determine as unidades de escala para o sistema em termos de conjuntos bem definidos de recursos. Isso torna a aplicação de operações de escalonamento horizontal mais fácil e menos propensa a um impacto negativo no aplicativo pelas limitações impostas por falta de recursos em alguma parte do sistema geral. Por exemplo, a adição de um número x de funções Web e de trabalho pode exigir um número y de filas adicionais e um número z de contas de armazenamento para lidar com a carga de trabalho extra gerada pelas funções. Assim, uma unidade de escala poderia consistir em x funções web e de trabalho, *y* filas e *z* contas de armazenamento. Crie o aplicativo para que ele seja facilmente dimensionado com a adição de uma ou mais unidades de escala.
* **Evite a afinidade do cliente**. Sempre que possível, verifique se o aplicativo não requer afinidade. As solicitações, portanto, podem ser roteadas para qualquer instância e o número de instâncias é irrelevante. Isso também evita a sobrecarga de armazenamento, de recuperação e de manutenção de informações de estado para cada usuário.
* **Aproveite os recursos de dimensionamento automático de plataforma**. Quando a plataforma de hospedagem der suporte a uma capacidade de dimensionamento automático, como o Dimensionamento Automático do Azure, dê preferência a ele em vez de a mecanismos personalizados ou de terceiros, a menos que o mecanismo interno não atenda aos seus requisitos. Use regras de dimensionamento agendadas quando possível para garantir que os recursos estejam disponíveis sem um atraso de inicialização, mas adicione o dimensionamento automático reativo às regras onde for apropriado para lidar com alterações inesperadas na demanda. Você pode usar as operações de dimensionamento automático na API de Gerenciamento de Serviços para ajustar o dimensionamento automático e adicionar contadores personalizados às regras. Para saber mais, confira [Diretrizes de dimensionamento automático](best-practices-auto-scaling.md).
* **Descarregue tarefas intensivas de CPU/ES como tarefas de segundo plano**. Se for esperado que uma solicitação para um serviço demore muito tempo para ser executada ou absorva recursos consideráveis, o descarregamento do processamento dessa solicitação será uma tarefa separada. Use funções de trabalho ou trabalhos em segundo plano (dependendo da plataforma de hospedagem) para executar essas tarefas. Essa estratégia permite que o serviço continue a receber outras solicitações e permaneça responsivo.  Para saber mais, consulte [Diretrizes de trabalhos em segundo plano](best-practices-background-jobs.md).
* **Distribua a carga de trabalho para tarefas em segundo plano**. Quando houver muitas tarefas em segundo plano, ou quando as tarefas exigirem um tempo ou recursos consideráveis, distribua o trabalho em várias unidades de computação (como funções de trabalho ou trabalhos em segundo plano). Para ver uma possível solução, confira [Padrão de Clientes Concorrentes](https://msdn.microsoft.com/library/dn568101.aspx).
* **Considere mudar para uma arquitetura de *nada compartilhado***. Uma arquitetura de nada compartilhado usa nós independentes e autossuficientes sem um ponto único de contenção (como serviços compartilhados ou armazenamento). Em tese, esse sistema pode ser dimensionado quase indefinidamente. Embora uma abordagem completa de nada compartilhado geralmente não seja prática para a maioria dos aplicativos, ela pode fornecer oportunidades de projetar uma escalabilidade melhor. Por exemplo, evitar o uso do estado de sessão do servidor, afinidade de cliente e particionamento de dados são bons exemplos de transição para uma arquitetura de nada compartilhado.

## <a name="data-management"></a>Gerenciamento de dados
* **Use o particionamento de dados**. Divida os dados em vários bancos de dados e servidores de banco de dados ou projete o aplicativo para usar os serviços de armazenamento de dados que podem fornecer esse particionamento de modo transparente (exemplos: Banco de dados Elástico do Banco de Dados SQL do Azure e Armazenamento de Tabelas do Azure). Esta abordagem pode ajudar a maximizar o desempenho e permitir o dimensionamento mais fácil. Há diferentes técnicas de particionamento, como horizontal, vertical e funcional. Você pode usar uma combinação delas para tirar o máximo proveito dessas técnicas com o aumento do desempenho de consultas, escalabilidade mais simples, gerenciamento mais flexível, melhor disponibilidade e para corresponder o tipo de repositório aos dados que serão armazenados. Além disso, considere usar tipos diferentes de repositórios de dados para diferentes tipos de dados, escolhendo os tipos com base em como eles são otimizados para o tipo de dados específico. Isso pode incluir usar o armazenamento de tabelas, um banco de dados do documento ou um repositório de dados familiar em coluna, em vez de ou além de um banco de dados relacional. Para saber mais, consulte [Diretrizes de particionamento de dados](best-practices-data-partitioning.md).
* **Projete para consistência eventual**. A consistência eventual melhora a escalabilidade ao reduzir ou remover o tempo necessário para sincronizar dados relacionados particionados em vários repositórios. O custo disso é que os dados nem sempre são consistentes quando lidos e algumas operações de gravação podem causar conflitos. A consistência eventual é ideal para situações em que os mesmos dados são lidos com frequência, mas gravados raramente. Para saber mais, confira [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).
* **Reduza as interações verborrágicas entre componentes e serviços**. Evite criar interfaces verborrágicas em que um aplicativo precisa fazer várias chamadas para um serviço (cada uma delas retorna uma pequena quantidade de dados), em vez de uma única chamada que pode retornar todos os dados. Sempre que possível, combine várias operações relacionadas em uma única solicitação quando a chamada é para um serviço ou componente que tem latência perceptível. Isso facilita o monitoramento do desempenho e otimiza operações complexas. Por exemplo, use procedimentos armazenados em bancos de dados para encapsular a lógica complexa e reduzir o número de viagens de ida e volta e o bloqueio de recursos.
* **Use filas para nivelar a carga de gravações de dados de alta velocidade**. Aumentos na demanda por um serviço podem sobrecarregar o serviço e causar falhas cada vez maiores. Para evitar isso, considere implementar o [Padrão de Nivelamento de Carga Baseado em Fila](https://msdn.microsoft.com/library/dn589783.aspx). Use uma fila que age como um buffer entre uma tarefa e um serviço chamado. Isso pode atenuar cargas pesadas intermitentes que, de outra forma, poderiam causar falha no serviço ou atingir o tempo limite da tarefa.
* **Minimize a carga no repositório de dados**. O repositório de dados é geralmente um gargalo de processamento, um recurso caro e nem sempre é fácil de escalar horizontalmente. Sempre que possível, remova a lógica (como o processamento de documentos XML ou objetos JSON) do repositório de dados e execute o processamento no aplicativo. Por exemplo, em vez de passar XML ao banco de dados (diferente de uma cadeia de caracteres opaca para armazenamento) serialize ou desserialize o XML dentro da camada de aplicativo e passe-o em um formato nativo para o repositório de dados. Em geral, é mais fácil escalar horizontalmente o aplicativo do que o repositório de dados; portanto, você deve tentar fazer o máximo de processamento intensivo de computação dentro do aplicativo possível.
* **Minimize o volume de dados recuperados**. Recupere somente os dados de que você precisa especificando colunas e usando critérios para selecionar linhas. Use parâmetros de valor de tabela e o nível de isolamento apropriado. Use mecanismos, como marcas da entidade, para evitar a recuperação de dados desnecessariamente.
* **Use o caching de forma agressiva**. Use o caching sempre que possível para reduzir a carga sobre recursos e serviços que geram ou entregam dados. O caching normalmente é adequado para dados relativamente estáticos ou que requerem processamento considerável para ser obtidos. O caching deve ocorrer em todos os níveis, quando apropriado, em cada camada do aplicativo, incluindo acesso a dados e a geração de interface do usuário. Para saber mais, consulte [Diretrizes de caching](best-practices-caching.md).
* **Lide com o crescimento e a retenção de dados**. A quantidade de dados armazenados por um aplicativo aumenta ao longo do tempo. Esse crescimento aumenta os custos de armazenamento e a latência ao acessar os dados, o que afeta o desempenho e a produtividade do aplicativo. É possível arquivar periodicamente alguns dos dados antigos que não são mais acessados ou mover dados raramente acessados para o armazenamento de longo prazo, que é mais econômico até mesmo do que a latência de acesso é superior.
* **Otimize DTOs (Data Transfer Objects, Objetos de Transferência de Dados) usando um formato binário eficiente**. Os DTOs são passados diversas vezes entre as camadas de um aplicativo. A minimização do tamanho reduz a carga sobre os recursos e a rede. No entanto, equilibre a economia com a sobrecarga de converter os dados para o formato necessário em cada local onde ele é usado. Adote um formato que tenha o máximo de interoperabilidade para permitir que um componente seja reutilizado facilmente.
* **Defina o controle de cache**. Crie e configure o aplicativo para usar o caching de saída ou caching de fragmento sempre que possível para minimizar a carga de processamento.
* **Habilite o caching do cliente**. Os aplicativos Web devem habilitar as configurações de cache no conteúdo que podem ser armazenadas em cache. Normalmente, isso está desabilitado por padrão. Configure o servidor para fornecer os cabeçalhos de controle de cache apropriados para habilitar o caching de conteúdo em clientes e servidores proxy.
* **Use o Armazenamento de Blobs do Azure e a Rede de Distribuição de Conteúdo do Azure para reduzir a carga no aplicativo**. Considere armazenar conteúdo público estático ou relativamente estático, como imagens, recursos, scripts e folhas de estilo no armazenamento de blobs. Essa abordagem reduz a aplicação da carga causada pela geração dinâmica desse conteúdo para cada solicitação. Além disso, considere o uso da Rede de Distribuição de Conteúdo para armazenar em cache esse conteúdo e entregá-lo aos clientes. O uso da Rede de Distribuição de Conteúdo pode melhorar o desempenho no cliente porque o conteúdo é distribuído do datacenter geograficamente mais próximo que contém um cache de Rede de Distribuição de Conteúdo. Para saber mais, confira a [Diretriz da Rede de Distribuição de Conteúdo](best-practices-cdn.md).
* **Otimize e ajuste consultas e índices SQL**. Algumas instruções ou construções T-SQL podem ter um impacto no desempenho que pode ser reduzido otimizando-se o código em um procedimento armazenado. Por exemplo, evite a conversão de tipos **datetime** em **varchar** antes de comparar com um valor literal **datetime**. Em vez disso, use funções de comparação de data/hora. A falta de índices adequados pode tornar a execução da consulta lenta. Se você usar uma estrutura de objeto/mapeamento relacional, entenda como ela funciona e como pode afetar o desempenho da camada de acesso aos dados. Para saber mais, consulte [Ajuste de consulta](https://technet.microsoft.com/library/ms176005.aspx).
* **Considere cancelar a normalização dos dados**. A normalização dos dados ajuda a evitar a duplicação e inconsistência. No entanto, manter vários índices, procurar a integridade referencial, executar vários acessos a pequenos fragmentos de dados e unir tabelas para remontar os dados impõe uma sobrecarga que pode afetar o desempenho. Considere se alguns volumes de armazenamento adicionais e a duplicação são aceitáveis para reduzir a carga no repositório de dados. Além disso, considere se o aplicativo em si (que normalmente é mais fácil de dimensionar) pode ser confiável para assumir o controle de tarefas, como gerenciar a integridade referencial para reduzir a carga no armazenamento de dados. Para saber mais, consulte [Diretrizes de particionamento de dados](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Implementação de serviço
* **Use chamadas assíncronas**. Sempre que possível, use o código assíncrono ao acessar recursos ou serviços que podem ser limitados por E/S ou largura de banda de rede, ou que tenham uma latência perceptível, para evitar o bloqueio do thread de chamada. Para implantar operações assíncronas, use o [TAP (padrão assíncrono baseado em tarefa)](https://msdn.microsoft.com/library/hh873175.aspx).
* **Evite o bloqueio de recursos e use uma abordagem otimista**. Nunca bloqueie o acesso a recursos como armazenamento ou outros serviços que tenham latência perceptível, pois essa é a causa principal de mau desempenho. Sempre use abordagens otimistas para gerenciar operações simultâneas, como gravar no armazenamento Use recursos da camada de armazenamento para gerenciar conflitos. Em aplicativos distribuídos, os dados só podem ser eventualmente consistentes.
* **Faça a compactação de dados altamente compactáveis em redes de baixa largura de banda e alta latência**. Na maioria dos casos, em um aplicativo Web, o maior volume de dados gerados pelo aplicativo e passado pela rede é constituído de respostas HTTP para solicitações do cliente. A compactação HTTP pode reduzir isso consideravelmente, em especial para conteúdo estático. Isso pode reduzir custos e a carga na rede, embora a compactação de conteúdo dinâmico aplique uma carga ligeiramente maior ao servidor. Em outros ambientes mais generalizados, a compactação de dados pode reduzir o volume de dados transmitidos para minimizar o tempo e os custos de transferência, mas adiciona uma sobrecarga aos processos de compactação e descompactação. Ela só deverá ser usada quando houver um ganho de desempenho demonstrável. Outros métodos de serialização, como JSON ou binário, podem reduzir o tamanho da carga ao mesmo tempo em que têm menos impacto no desempenho, enquanto o XML provavelmente vai aumentá-lo.
* **Minimize o tempo de uso de conexões e recursos**. Mantenha conexões e recursos apenas pelo tempo necessário para usá-los. Por exemplo, abra conexões o mais tarde possível e permita que elas sejam retornadas ao pool de conexões assim que possível. Adquira recursos o mais tarde possível e descarte-os assim que possível.
* **Minimize o número de conexões necessárias**. As conexões de serviço absorvem recursos. Limite o número necessário e verifique se as conexões existentes são reutilizadas sempre que possível. Por exemplo, depois de executar a autenticação, use a representação onde for apropriado para executar o código como uma identidade específica. Isso pode ajudar a fazer o melhor uso do pool de conexões com sua reutilização.
  
  > [!NOTE]
  > : as APIs para alguns serviços reutilizam automaticamente as conexões, desde que as diretrizes específicas do serviço sejam seguidas. É importante entender as condições que permitem a reutilização da conexão para cada serviço usado por seu aplicativo.
  > 
  > 
* **Envie solicitações em lotes para otimizar o uso da rede**. Por exemplo, envie e leia mensagens em lotes ao acessar uma fila e execute várias leituras ou gravações em lote ao acessar um cache ou armazenamento. Isso pode ajudar a maximizar a eficiência dos serviços e os armazenamentos de dados, reduzindo o número de chamadas na rede.
* **Evite um requisito de armazenar o estado de sessão do servidor** sempre que possível. O gerenciamento de estado de sessão do servidor geralmente requer afinidade de cliente (ou seja, o roteamento de cada solicitação para a mesma instância de servidor), o que afeta a capacidade de dimensionamento do sistema. Em tese, você deve criar clientes sem monitoração de estado em relação os servidores que eles usam. No entanto, se o aplicativo precisar manter o estado de sessão, armazene dados confidenciais ou grandes volumes de dados por cliente em um cache de servidor distribuído que todas as instâncias do aplicativo podem acessar.
* **Otimize esquemas de armazenamento de tabela**. Ao usar armazenamentos de tabela que exigem que os nomes da tabela e das colunas sejam passados e processados com cada consulta, como o armazenamento de tabelas do Azure, considere usar nomes menores para reduzir essa sobrecarga. No entanto, não sacrifique a legibilidade ou a capacidade de gerenciamento usando nomes excessivamente compactos.
* **Usar a TPL (Task Parallel Library, Biblioteca de Paralelismo de Tarefas) para realizar operações assíncronas**. A TPL facilita a gravação de código assíncrono que executa operações vinculadas de E/S. Use *ConfigureAwait(false)* sempre que possível para eliminar a dependência de uma continuação em um contexto de sincronização específico. Isso reduz as chances de ocorrer deadlock de thread.
* **Crie dependências de recursos durante a implantação ou a inicialização do aplicativo**. Evite chamadas repetidas para métodos que testam a existência de um recurso e crie o recurso se ele não existir. (Métodos como *CloudTable.CreateIfNotExists* e *CloudQueue.CreateIfNotExists* na biblioteca de cliente do Armazenamento do Azure seguem esse padrão.) Esses métodos podem impor uma sobrecarga considerável se forem chamados antes de cada acesso a uma tabela de armazenamento ou uma fila de armazenamento. Em vez disso:
  * Crie os recursos necessários quando o aplicativo for implantado ou quando for iniciado pela primeira vez (uma única chamada para *CreateIfNotExists* para cada recurso no código de inicialização para uma função web ou de trabalho é aceitável). No entanto, não se esqueça de manipular as exceções que poderão surgir se o seu código tentar acessar um recurso que não existe. Nessas situações, você deve registrar a exceção e, possivelmente, alertar um operador sobre a ausência de um recurso.
  * Em alguns casos, pode ser apropriado criar o recurso ausente como parte do código de tratamento de exceções. Mas você deve adotar essa abordagem com cuidado, já que a ausência do recurso pode ser uma indicação de um erro de programação (um nome de recurso incorreto, por exemplo) ou algum outro problema a nível da infraestrutura.
* **Use estruturas leves**. Escolha cuidadosamente as APIs e estruturas que você utiliza para minimizar o uso de recursos, o tempo de execução e a carga geral no aplicativo. Por exemplo, o uso da API Web para tratar das solicitações de serviço pode reduzir a superfície do aplicativo e aumentar a velocidade de execução, mas talvez não seja adequado para cenários avançados, onde são necessários recursos adicionais da Windows Communication Foundation.
* **Considere minimizar o número de contas de serviço**. Por exemplo, usar uma conta específica para acessar recursos ou serviços que impõem um limite de conexões ou têm desempenho melhor quando menos conexões são mantidas. Essa abordagem é comum para serviços como bancos de dados, mas ela pode afetar a capacidade de auditar operações com precisão devido à representação do usuário original.
* **Execute testes de perfil e carga de desempenho** durante o desenvolvimento, como parte das rotinas de teste, e antes da liberação o final para assegurar o desempenho e o dimensionamento necessários para o aplicativo. Esse teste deve ocorrer no mesmo tipo de hardware da plataforma de produção e com os mesmos tipos e quantidades de dados e carga de usuário que serão encontrados em produção. Para saber mais, confira [Testando o desempenho de um serviço de nuvem](vs-azure-tools-performance-profiling-cloud-services.md).




<!--HONumber=Nov16_HO3-->


